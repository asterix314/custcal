/****************************************
    存储过程：    `存储过程`
    业务描述：    `业务名称`（`业务摘要`）
*****************************************/

if exists (select * from sysobjects where type = 'P' and name = '`存储过程`')
    drop proc `存储过程`
go
/*
select top 10 * from `业务流水` where digestid = `业务摘要`
update `业务流水` set sett_status = 0, sett_remark = '' where digestid = `业务摘要`

declare @ret as int, @msg as varchar(128)
exec @ret=`存储过程` '2', 20150804, 17795, 180399995492, @msg output
select @ret, @msg

select * from `持仓核算`
select * from `资金核算`
*/
CREATE proc `存储过程`(
 @serverid  char(1)      
,@bizdate   int          
,@sno       int
,@custid    bigint    
,@msg       varchar(128) =null output
)
with encryption
as
declare @orgid as varchar(4), @fundid as bigint, @digestid as int, @market as char(1), @stkcode as varchar(10), 
        @stkeffect as numeric(20,2), @matchqty as numeric(20,2), @matchamt as numeric(20,2), @bankcode as varchar(4), 
        @moneytype as char(1), @fundeffect as numeric(20,2), @fee_sxf as numeric(20,2), 
        @fee_jsxf as numeric(20,2), @fee_ghf as numeric(20,2), @fee_yhs as numeric(20,2), @qtfee as numeric(20,2), 
        @ordersno as bigint, @orderdate as int, @sett_status as char(1)
declare @ref_stkcode as varchar(10), @ref_market as char(1), @stkprice as numeric(12,4),
        @rowcount as int, @ret as int
        
 select @orgid=orgid, @fundid=fundid, @digestid=digestid, @market=market, @stkcode=stkcode, 
        @stkeffect=stkeffect, @matchqty=matchqty, @fundeffect=fundeffect, @matchamt=matchamt, 
        @fee_sxf=fee_sxf, @fee_jsxf=fee_jsxf, @fee_ghf=fee_ghf, @fee_yhs=fee_yhs,
        @qtfee=fee_qsf+fee_jygf+fee_jsf+fee_zgf+fee_qtf+feefront, 
        @bankcode=bankcode, @moneytype=moneytype, @ordersno=ordersno, @orderdate=orderdate,
        @sett_status=sett_status
   from `业务流水`
  where sno=@sno and bizdate=@bizdate and serverid=@serverid and custid=@custid and digestid = `业务摘要` -- `业务名称`

begin try
   if (@sett_status is null)
      begin
         select @msg='该笔流水不存在或调用错误.'
         raiserror(' %s', 12, 1, @msg) with SETERROR
      end

   if (@sett_status='3')
      begin
         select @msg='该笔流水已处理.'
         return 0
      end

   if (@fundeffect=0)
      begin
         select @msg='资金发生与该业务不符.'
         raiserror(' %s', 12, 1, @msg) with SETERROR
      end

   if (@fee_sxf!=0 or @fee_jsxf!=0 or @fee_ghf!=0 or @fee_yhs!=0 or @qtfee!=0)
       begin
          select @msg='费用金额异常.'
          raiserror(' %s', 12, 1, @msg) with SETERROR
       end

begin tran
   -- 更新持仓核算表：利息税
    update `持仓核算`
       set lxs = lxs - @fundeffect, lxs_ch = lxs_ch - @fundeffect
     where serverid=@serverid and orgid=@orgid and custid=@custid and fundid=@fundid and
           market=@market and stkcode=@stkcode and ltlx='`流通类型`' -- 主键

    select @rowcount=@@rowcount
    if (@rowcount>1)    
       begin
          select @msg='更新证券持仓行数错误(rowcount='+CONVERT(varchar, @rowcount)+').'       
          raiserror(' %s', 12, 2, @msg) with SETERROR                   
       end
       else if (@rowcount=0)
       begin
          insert `持仓核算`
                 (serverid, orgid, custid, fundid, market, stkcode, ltlx, 
                 stkbuyqty, stkbuyamt, stksaleqty, stksaleamt, stkbuyqty_ex, stkbuyamt_ex, stksaleqty_ex, stksaleamt_ex, 
                 stkztgrqty, stkztgramt, stkztgcqty, stkztgcamt, stkhgqty, stkhlamt, stkpgqty, stkpgamt, 
                 stkqty, stkqty_ch, stkqty_tz, stkqty_tzje, stkpledge, stkdebt, stkdebt_ch, stkloan,
                 stkloan_ch, stkadjust, stkadjust_ch, stkprice, bondintr, mktvalue, aiamount, stkcost,
                 stkcost_ch, aicost, aicost_ch, syvalue, syvalue_ch, lxsr, lxsr_ch, gyvalue,
                 gyvalue_ch, lxjt, lxjt_ch, cjsr, cjsr_ch, jrzc, jrzc_ch, sxf,
                 sxf_ch, jsxf, jsxf_ch, yhs, yhs_ch, lxs, lxs_ch, ghf,
                 ghf_ch, qtfee, qtfee_ch, jtdate, gydate, remark, stkpledge_ch, yearqty,
                 yeargyvalue, yearlxjt)
          values (@serverid, @orgid, @custid, @fundid, @market, @stkcode, '`流通类型`',
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,-@fundeffect,-@fundeffect,0,
                 0,0,0,0,0,'',0,0,
                 0,0);
       end    

    update `资金核算`
       set fundbal=fundbal+@fundeffect, fundbal_ch=fundbal_ch+@fundeffect
     where serverid=@serverid and orgid=@orgid and custid=@custid and bankcode=@bankcode and
           fundid=@fundid and moneytype=@moneytype -- primary key
           
    select @rowcount=@@rowcount
    if (@rowcount>1)    
       begin
          select @msg='更新资金行数错误(rowcount='+CONVERT(varchar, @rowcount)+').'       
          raiserror(' %s', 12, 2, @msg) with SETERROR                   
       end
       else if (@rowcount=0)
       begin
          insert `资金核算`
                 (serverid, orgid, custid, fundid, moneytype, bankcode,
                 fundbal, fundbal_ch, fundsave, fundsave_ch, fundunsave, fundunsave_ch, fundloan, fundloan_ch,
                 funddebt, funddebt_ch, funduncome, funduncome_ch, fundunpay, fundunpay_ch, fundintr, fundintr_ch,
                 fundaward, fundaward_ch, fundadjust, fundadjust_ch, fundlastbal, totalvalue, tjdate, remark,
                 nav, mktvalue, totalfe, rzlx, rzlx_ch)
          values (@serverid, @orgid, @custid, @fundid, @moneytype, @bankcode,
                 @fundeffect, @fundeffect,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,0,
                 0,0,0,0,0,0,0,'',
                 0,0,0,0,0);
       end

      select @msg='核算处理成功'
      update `业务流水`
         set sett_status=3, sett_remark=@msg
       where serverid=@serverid and bizdate=@bizdate and sno=@sno
   
   commit tran
   return 0
end try
begin catch
   if @@trancount > 0
       rollback tran

   select @msg='失败:' + error_message() + ''
   
   update `业务流水` 
      set sett_status=4, sett_remark=@msg
    where sno=@sno and bizdate=@bizdate and serverid=@serverid

   return -1
end catch
go
